<h1>Java虚拟机</h1>

### JVM内存模型
- **程序计数器**： 一个内存容量较小的空间，线程私有，是当前线程所执行的字节码行号指示器。执行方法时记录的时字节码的指令地址，这是JVM中唯一没有内存溢出问题的区域
- **Java虚拟机栈**： 线程私有，用于存放方法执行的栈帧。当线程请求的栈深度大于虚拟机允许的深度，会抛出StackOverFlow异常，若无法申请到更多的内存存放栈帧，则抛出OutOfMemory异常
- **本地方法栈**： 与Java虚拟机栈的功能类似，不同点在于只存放Native方法的栈帧
- **Java堆**： 虚拟机管理内存最大的一块区域，唯一目的是存放运行时的对象实例。共享内存区域、垃圾收集器管理的主要区域
- **方法区**： 共享内存区域，存放加载的类信息、常量、静态变量，永久代所在区域
- **运行时常量池**： 方法区的一部分。存放编译器生成的各种字面量和符号引用

### new一个对象的过程
1. 检查这个指令的参数是否能在运行时常量池中定位到一个类的符号引用，并检查这个符号代表的类是否已被加载、解析、初始化过。没有则进行这些过程
2. 为新对象分配内存
3. 将分配到的内存空间初始化为零值
4. 对对象进行必要设置(例如元数据信息)
5. 执行<init>方法，按程序的意愿进行初始化

### 对象的内存布局与对象的访问定位
对象内存布局：对象头、实例数据、对齐填充(因为一个对象的大小为8字节的整数倍)

对象的访问定位：
- **句柄**： Java堆中使用一块内存作为句柄池，存放实例数据与内心数据各自的地址信息
- **直接指针**： 使用reference直接存放对象的地址信息

## 垃圾收集器与内存分配策略
### 对象如何被判定为垃圾
使用GC Root可达性分析算法。通过“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象时不可用的。

### Java的引用
- **强引用**： 类似Object obj = new Object(), obj就是一个强引用
- **软引用**： 一些还有用但并非必需的对象，将要发生内存溢出的时候垃圾收集器才会回收对应的对象
- **弱引用**： 与软引用类似，但是只能生存到下一次垃圾回收
- **虚引用**： 如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收

### 垃圾回收算法
1. **标记-清除算法**： 分为两个过程，标记需要回收的对象，回收所有标记对象。不足之处： 两个过程效率不高；会产生大量不连续的内存碎片
2. **复制算法**： 将内存分为两块，一次使用一块，用完一块，复制存活对象到另一块内存中，然后回收有垃圾的内存空间，虽然高效，但是浪费空间。 改进： 98%的对象朝生夕死，将内存空间分为1个Eden空间和两个survivor空间，这两个空间的大小比为8:1。Eden空间中的对象死亡之后复制存活的对象到一个survivor空间中，然后清除Eden空间，如果存放对象的survivor空间中的对象过期了，则将存活对象复制到另一块survivor空间中，清理这块空间中的垃圾。
3. **标记-整理算法**： 标记后让存活的对象移动至一端，然后清理剩余空间的垃圾

### 垃圾回收的过程
垃圾回收分为两次标记过程。第一次标记回收时执行对象的finalize()方法，可以覆盖对象的finalize()方法使得调用方法时重新激活对象，下一次标记垃圾对象时仍无法重新激活的对象将被垃圾回收器回收

### 方法区(永久代)的垃圾回收
方法区主要存放类信息与常量，类回收的条件： 类的所有实例都被回收；加载类的classLoader被回收；在任何地方没有引用；无法通过发射机制访问该类的信息

### 安全点
HotSpot在JIT编译过程中，会在特定的位置记录下栈和寄存器中哪些位置是引用，这个位置称为安全点。程序执行时只有到达安全点时才会执行GC。一般选定方法调用、循环跳转、异常跳转等，会产生安全点。GC发生时会让所有的线程都执行到最近的安全点上再停顿。有两种方案：抢先式中断和主动式中断
- 抢先式中断： GC发生时，首先把所有的线程全部中断，如果有线程中断不在安全点上，就恢复线程，使其执行到安全点上
- 主动式中断：不直接对线程操作，简单的设置一个标志，各个线程执行时去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点时重合的

### 安全区域
如果线程处于sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求。对于这种情况就需要安全区域来解决。安全区域是指一段代码片段之中，引用关系不会发生变化。在这个区域的任何地方开始GC都是安全的。我们可以吧安全区域看做扩展的安全点。  当线程执行到了安全区域中的代码时，首先标志自己进入了安全区域，当发生GC时，就不用管该线程了

### 垃圾收集器
- **Serial收集器**： 新生代收集器；单线程收集器；运行时必须暂停所有线程；使用复制算法
- **ParNew收集器**： Serial收集器的多线程版本；只有这个收集器能与CMS收集器配合
- **Parallel Scavenge收集器**： 使用复制算法；重心是吞吐量，可以控制吞吐量，高效利用CPU时间；新生代收集器
- **Serial Old收集器**： Serial收集器的老年代版本；使用标记-整理算法
- **Parallel Old收集器**： Parallel Scavenge收集器的老年代版本；使用标记-整理算法
- **CMS收集器**： 以最短回收停顿时间为目标的收集器，使用标记清除算法；4个步骤： 初始标记、并发标记、重新标记、并发清除； 缺点： 1.标记-清除算法的缺点； 2.对CPU资源非常敏感； 3.无法处理浮动垃圾
- **G1收集器**： 一款面向服务器的垃圾收集器，G1可以充分使用多个CPU，利用并发方式让Java程序继续运行；采用不同的方式进行分代垃圾收集；整体采用“标记—整理”算法，局部（region之间）采用“复制”算法；能使使用者明确指定在一个长度为M毫秒的时间片段，消耗在垃圾收集器上的时间不超过N毫秒

    G1将整个Java堆分为多个大小相等的独立区域（region），新生代与老年代不再物理隔离，他们都是一部分Region的集合。G1可以通过每一个Region垃圾回收的价值，去回收价值最大的

    G1收集器中，Region中对象的相互引用（其他收集器新生代与老年代的对象引用），虚拟机使用Remembered Set来避免全栈扫描。G1中每个Region都有一个对应的Remembered Set，当虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收，在GC根节点的枚举范围加入Remembered Set 保证不对全栈扫描

    G1收集器运作分为 1.初始标记 2.并发标记 3.最终标记 4.筛选回收。初始标记仅仅标记一下GC Roots能直接关联到的对象，并让下一阶段用户线程并发进行，这个阶段需要暂停，但是耗时很短；并发标记从GC Roots对堆中对象进行可达性分析，找出存活对象，可与用户线程一起运行，耗时长；最终标记修整并发标记时程序持续运行发生变化的标记记录，将对象变化记录在线程的Remembered Set Logs中，在将其中数据合并到Remembered Set中，需要停顿，可并行执行。筛选回收对各个Region的回收价值和成本记性排序，根据用户的期望进行回收

### 内存分配与回收策略
- 对象优先在Eden区分配，空间不足先minorGC
- 长期存活对象将直接进入老年代
- 空间分配担保，minorGc之前，检查老年代最大可用的连续空间是否大于新生代所有存活对象的空间。是的话，minorGC是安全的，否则看JVM设置是否允许这种情况下进行MinorGC，是的话就进行MinorGC,尽管有风险，否则进行FullGC

### * 虚拟机性能监控与故障处理工具
- jps: 虚拟机进程状况查看工具们列出正在运行的虚拟机进程，并显示执行主类
- jstat: 虚拟机统计信息监视工具，监视各种运行状态信息
- jinfo：展示jvm的配置参数信息
- jmap：jvm内存映像工具，生成堆存储快照，也可以用于查询finalize执行队列、java堆和永久代的详细信息
- jhat: 与jmap搭配使用，用于分析jmap生成的快照
- jstack: 用于生成当前时刻的线程快照
- jconsole: 基于jmx的可视化监视管理工具

### 类的生命周期
加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

### 类生命周期详解
- 加载： 通过类的全限定名在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据访问的入口
- 验证： 确保class文件的字节流中包含的信息符合当前虚拟机的要求(例：魔数、版本)
- 准备： 真实为类变量分配内存并设置类变量的初始值，static变量会直接赋代码的值
- 解析： 将产量池中的符号引用替换为直接引用的过程
- 初始化： 执行类中自定义的代码

### Java类加载器
启动类加载器(root)、扩展加载器(extention)、应用程序加载器(application)

### 双亲委派机制
类加载器收到类加载请求之后，首先会委托父类加载器加载该类，如果父类没有加载过，则会返回给原来的加载器进行加载。为了安全，比如恶意的写一个java.util.String类，没有双亲委派机制会很危险

<h1>Java多线程知识点</h1>
以下Java多线程知识点是基于《Java多线程编程实战指南-核心篇》的总结归纳，强烈建议先完整阅读此书。

**带*号的知识点很少考察**

### 创建线程的方式及属性
1. **继承Thread类**。继承的方式有局限性，不符合面向接口编程的思想
2. **实现Runable接口**。符合面向接口变成的思想，但start()和run()无返回值
3. **实现callable接口**。在runnable的基础上可以返回Future对象，可用于监控线程的运行状态

直接运行run()方法是是单线程的，运行start()方法才是多线程

基本属性：id(线程id)，name(线程命名)，priority(线程运行的优先级)，daemon(线程类别。boolean。true为守护线程(性能消耗小)，false为用户线程(默认为false))

### 线程的生命周期
- **NEW**： 已创建但是未启动的线程
- **RUNABLE**： 可以被线程调度器调度或者正在运行的线程
- **BLOCKED**： 被阻塞或正在申请一个被持有的锁的线程
- **WAITING**： 执行了Objet.wait()，Thread.join()或者LockSupport.park()之后进入的状态
- **TIMED-WAITING**： 有超时限制的WAITING
- **TERMINATED**： 已结束的线程

### * 多线程的优势
- 提高吞吐率
- 提高响应性
- 充分利用多核
- 最小化资源的使用
- 简化程序的结构

### * 多线程的风险
- 安全问题
- **活性问题(死锁、锁死、活锁、线程饥饿)**
- **上下文切换**。 一个线程由于某种原因被剥夺处理器使用权，使用权分配到另一个线程
- 可靠性问题

### 多线程的三个性质
- **原子性**： 涉及共享变量的操作，该操作从执行线程以外的线程看来是不可分割的。使用锁和CAS保障原子性
- **可见性**： 一个线程更新共享变量之后，其他线程读取到的是更新之后的结果，使用synchronized、volatile保障可见性
- **有序性**： Java内存模型中，允许编译器和处理器对指令进行从排序，但是从排序过程不会影响到单线程程序的执行，却会影响多线程并发执行的正确性，使用happen-before规则保证有序性

### * happen-before规则
- 程序次序规则： 一个线程内，按照代码执行，书写在前面的操作先行发生于书写在后面的操作
- 锁定规则： 一个unlock操作线程发生于后面对同一个锁的lock操作
- volatile变量规则： 对一个变量的写操作先行于后面对这个变量的读操作
- 传递规则： 如果操作A先行发生于操作B，而操作B又嫌腥发生于操作C，则可以得出操作A先行发生于操作C
- 线程启动规则： Thread对象的start()方法先行发生于此线程的每个动作
- 线程终端规则： 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则： 线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()方法返回值手段检测到线程已经终止执行
- 对象终结规则： 一个对象的初始化完成先行发生于他的finalize()方法的开始

---

## Java同步机制
临界区： 获得锁之后到释放锁之前执行的代码称为临界区

可重入性： 一个线程在某个持有锁的时候可再次或多次申请该锁

锁的分类：
- 内部锁(synchronized)： 不会导致锁的泄漏，灵活性差
- 显示锁(Lock的实现类): 灵活性强，但使用不当容易造成活性问题

ReentrantLock(boolean fair) 可以控制锁的获取时候公平，公平调度增加了线程暂停和唤醒的可能性，开销比非公平大

ReadWriteLock(读写锁)的读锁可以被多个线程拥有，但是写锁只能被一个线程独占。读取的时候不允许写，写的时候不允许读取

内存屏障：锁的底层的实现是内存屏障。在写的时候插入读屏障，禁止读；读的时候插入写屏障，禁止写

### * 重排序规则(遵守happen-before规则)
1. 临界区内的操作不允许从排序到临界区外
2. 临界区内的操作允许重排序
3. 临界区外的操作之间可以被重排序
4. 锁的申请与释放操作不能被重排序
5. 两个锁的申请操作不能被重排序
6. 两个锁的释放操作不能被重排序
7. 临界区外的操作可以被重排序

### volatile关键字
java的内存模型分成**工作内存**和**主内存**，一般的操作都是在工作内存中完成，完成之后同步到主内存中，这个机制在多线程环境下容易出错。

- volatile修饰的变量具有可见性而且禁止与变量有关的指令的重排序，因为变量的操作不会在工作内存中完成
- 保证long/double在32位虚拟机中的读写操作的原子性(long/double是64位的数值，在32位虚拟机中是使用两个32位进行模拟)
- volatile变量读写都不会导致上下文切换
- 无法保证自增操作的原子性，因为自增操作在处理器底层已经限定在寄存器(工作内存)中完成

### CAS(if-then-happen操作)
CAS(Compare And Swap)是一种处理器指令，提供一个值A与值B，A值与共享变量做比较，如果相同，则证明没有修改，用B值替换。如果不相同，则再次尝试直到成功为止。乐观锁的形式，并发度很高的情况下不保证成功。保证原子性，不保证可见性。

Atomic包介绍(JDK自带)：
- 基础数据类型：AtomicInteger, AtomicLong, AtomicBoolean
- 数组型： AtomicIntegerArray, AtomicLongArray, AtomicReference
- 字段更新器： AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater
- 引用型： AtomicReference, AtomicStampedReference, AtomicMarkableReference

---

## 线程间协作



<a href="https://www.cnblogs.com/dolphin0520/p/3920407.html">ThreadLocal详细介绍</a>

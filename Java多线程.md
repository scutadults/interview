<h1>Java多线程知识点</h1>
以下Java多线程知识点是基于**《Java多线程编程实战指南-核心篇》**的总结归纳，强烈建议先完整阅读此书。

**带*号的知识点很少考察**

### 创建线程的方式及属性
1. **继承Thread类**：继承的方式有局限性，不符合面向接口编程的思想
2. **实现Runable接口**：符合面向接口编程的思想，但start()和run()无返回值
3. **实现callable接口**：在runnable的基础上可以返回Future对象，可用于监控线程的运行状态

直接运行run()方法是是单线程的，运行start()方法才是多线程

基本属性：id(线程id)，name(线程命名)，priority(线程运行的优先级)，daemon(线程类别、boolean、true为守护线程(性能消耗小)、false为用户线程(默认为false))

### 线程的生命周期
- **NEW**： 已创建但是未启动的线程
- **RUNABLE**： 可以被线程调度器调度或者正在运行的线程
- **BLOCKED**： 被阻塞或正在申请一个被持有的锁的线程
- **WAITING**： 执行了Objet.wait()，Thread.join()或者LockSupport.park()之后进入的状态
- **TIMED-WAITING**： 有超时限制的WAITING
- **TERMINATED**： 已结束的线程

### * 多线程的优势
- 提高吞吐率
- 提高响应性
- 充分利用多核
- 最小化资源的使用
- 简化程序的结构

### * 多线程的风险
- 安全问题
- **活性问题(死锁、锁死、活锁、线程饥饿)**
- **上下文切换**。 一个线程由于某种原因被剥夺处理器使用权，使用权分配到另一个线程
- 可靠性问题

### 多线程的三个性质
- **原子性**： 涉及共享变量的操作，该操作从执行线程以外的线程看来是不可分割的。使用锁和CAS保障原子性
- **可见性**： 一个线程更新共享变量之后，其他线程读取到的是更新之后的结果，使用synchronized、volatile保障可见性
- **有序性**： Java内存模型中，允许编译器和处理器对指令进行从排序，但是从排序过程不会影响到单线程程序的执行，却会影响多线程并发执行的正确性，使用happen-before规则保证有序性

### * happen-before规则
- **程序次序规则**： 一个线程内，按照代码执行，书写在前面的操作先行发生于书写在后面的操作
- **锁定规则**： 一个unlock操作线程发生再对同一个锁的lock操作之后
- **volatile变量规则**： 对一个变量的写操作先行于后面对这个变量的读操作
- **传递规则**： 如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- **线程启动规则**： Thread对象的start()方法先行发生于此线程的每个动作
- **线程终端规则**： 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- **线程终结规则**： 线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()方法返回值手段检测到线程已经终止执行
- **对象终结规则**： 一个对象的初始化完成先行发生于他的finalize()方法的开始

---

## Java同步机制
**临界区**： 获得锁之后到释放锁之前执行的代码称为临界区

**可重入性**： 一个线程在某个持有锁的时候可再次或多次申请该锁

锁的分类：
- **内部锁(synchronized)**： 不会导致锁的泄漏，灵活性差
- **显式锁(Lock的实现类)**: 灵活性强，但使用不当容易造成活性问题

**ReentrantLock(boolean fair)** 可以控制锁的获取时候公平性，公平调度增加了线程暂停和唤醒的可能性，开销比非公平大

ReadWriteLock(读写锁)的读锁可以被多个线程拥有，但是写锁只能被一个线程独占。读取的时候不允许写，写的时候不允许读取

内存屏障：锁的底层的实现是内存屏障。在写的时候插入读屏障，禁止读；读的时候插入写屏障，禁止写

### * 重排序规则(遵守happen-before规则)
1. 临界区内的操作不允许重排序到临界区外
2. 临界区内的操作允许重排序
3. 临界区外的操作之间可以被重排序
4. 锁的申请与释放操作不能被重排序
5. 两个锁的申请操作不能被重排序
6. 两个锁的释放操作不能被重排序
7. 临界区外的操作可以被重排序到临界区内

### volatile关键字
java的内存模型分成**工作内存**和**主内存**，一般的操作都是在工作内存中完成，完成之后同步到主内存中，这个机制在多线程环境下容易出错。

- volatile修饰的变量具有可见性而且禁止与变量有关的指令的重排序，因为变量的操作不会在工作内存中完成
- volatile关键字修饰的变量更新之后会使工作内存中的缓存无效化
- 保证long/double在32位虚拟机中的读写操作的原子性(long/double是64位的数值，在32位虚拟机中是使用两个32位进行模拟)
- volatile变量读写都不会导致上下文切换
- 无法保证自增操作的原子性，因为自增操作在处理器底层已经限定在寄存器(工作内存)中完成

### CAS(if-then-happen操作)
CAS(Compare And Swap)是一种处理器指令，提供一个值A与值B，A值与共享变量做比较，如果相同，则证明没有修改，用B值替换。如果不相同，则再次尝试直到成功为止。乐观锁的形式，并发度很高的情况下不保证成功。保证原子性，不保证可见性。

Atomic包介绍(JDK自带)：
- 基础数据类型：AtomicInteger, AtomicLong, AtomicBoolean
- 数组型： AtomicIntegerArray, AtomicLongArray, AtomicReference
- 字段更新器： AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater
- 引用型： AtomicReference, AtomicStampedReference, AtomicMarkableReference

---

## 线程间协作及通信

### Object.wait()和Object.notify()
wait()和notify()用于实现线程的等待和唤醒，使用内部锁

开销及问题(详见《Java多线程编程实战指南-核心篇》 P189)：
- 过早唤醒
- 信号丢失
- 欺骗性唤醒
- 上下文切换

一般使用notifyAll()进行线程的唤醒，因单个使用notify()容易出错。使用notify()的场景： 1.一次通知只需要唤醒至多一个线程 2.相应对象上的所有等待线程都是同质线程

Condition.await()/Condition.signal()替代Object.wait()/Object.notify()可以避免过早唤醒问题，使用的是显式锁

### * 为什么wait()和notify()方法不放在Thread类中
Java提供的锁是对象级而不是线程级的，每个对象都有锁，通过线程获取。如果方法定义在Thread类中，那么线程正在等待哪个锁不能明显知道

### * wait()和sleep()的区别
wait()用于线程间通信，执行时会释放所持有的锁和CPU资源。sleep()仅仅释放CPU资源，让线程等待，但不会释放锁

### * 倒计时协调器 -- CountDownLatch
**实现一个或多个线程等待其他线程完成一组特定的操作之后才能继续运行的功能**。内部会维护一个用于表示未完成的先决操作的计数器，计数器不为0时，执行CountDownLatch.await()的线程会被暂停，为0时会唤醒所有CountDownLatch上等待的线程。

若内部错误导致内部的计数无法到0，所有的线程都将一直为WAITING状态。避免方法： 1.确保countDown()方法的调用在代码的正确位置。 2.等待线程在等待先决操作完成的时候指定一个时间限制，超时就会唤醒CountDownLatch上的所有线程

### * 栅栏 -- CyclicBarrier
多个线程需要等待所有线程执行到代码中某个地方，程序才能继续执行，这时使用CyclicBarrier比较合适。内部维护一个初始为0的计数器，指定一个值，到执行点则计数器+1，并且对应的线程调用CyclicBarrier.await()方法。最后一个执行的线程会唤醒所有等待线程。

### * CountDownLatch vs CyclicBarrier
对比项|CountDownLatch|CyclicBarrier
---|:--:|:--:
**计数器**|减法|加法
**释放线程条件**|计数为0|计数为指定值
**利用性**|无法重置，不可重复使用|可以重置为0，重复使用
**阻塞性**|会阻塞主线程|只会阻塞子线程

### 阻塞队列
- **ArrayBlockingQueue**： 基于数组。put()、take()使用的是同一个锁，容易导致高争用、上下文切换的问题。适合并发度较低的情况
- **LinkedBlockingQueue**： 基于链表。put()、take()使用两个锁，垃圾回收的负担较大。适合并发度较高的情况
- **SynchronousQueue**： take()的时候无元素会阻塞等待，put()只执行一次，直到队列中的元素被消费。适合生产者和消费者速率差不多的情况
- **Semaphore**： 用于控制流量。acquire()/release()分别用于申请和返回配额。配额不足的时候，acquire会执行线程暂停
- **Exchanger**： 双缓冲。相当于两个队列，一个容量用完之后，生产者切换到另一个队列中生产，消费者继续在当前队列消费，直到消费完成之后切换队列

#### ThreadLocal
ThradLocal是典型的牺牲空间换取线程安全的类，详细介绍请看： <a href="https://www.cnblogs.com/dolphin0520/p/3920407.html">ThreadLocal详细介绍</a>

### 死锁产生的条件
产生死锁必定全部成立，全部成立不一定产生死锁
1. 资源互斥
2. 资源不可抢夺
3. 占用并等待资源
4. 循环等待资源

### 规避死锁的方法
- 粗锁法。使用粗粒度锁代替多个锁，降低了并发性并可能导致资源浪费
- 锁排序法。按一定的顺序申请锁
- 使用ReentrantLock.tryLock(long time)申请锁
- 使用锁的替代品

## 线程管理

### 使用线程池的原因
- 线程的创建、启动、销毁、调度的开销
- 可以创建的线程的数量其实受CPU限制

### 几个线程池大小的概念
- 线程池大小： 内部维护的工作者线程数量
- 当前线程池大小： 实际工作的线程的数量
- 最大线程池大小： 允许存在的工作者线程的数量上限

### Executor框架
Executor: void execute(Runnable command)， 其实现类为ThreadPoolExecutor
ThreadPool.submit(Callable<T>)

### 几个线程池实例
- newCachePool()： 适合用于执行大量好事短且提交比较频繁的任务
- newFixedPool()： 适合用于线程数量已知的情况
- new SingleThreadExecutor()： 适合用来实现生产者 - 单消费者的情况

### Future类
对于具体的Runnable或者callable任务的执行结果进行取消、查询是否完成、获取结果的类

### 线程池的submit()和execute()方法有何区别
execute()返回void， submit返回Future。execute()会抛出异常，submit()不会抛出异常，但可以用future.get()获取异常信息
